#version 330 core

out vec4 color;
in vec2 screen_pos;
in vec2 uvs;
uniform sampler2D pdf_texture;
uniform float contrast;
uniform float transparency;
uniform float blur_amount;  // Blur strength: 0.0 = no blur, 1.0 = full blur
uniform float dark_mode_bg_threshold_low;   // Dark mode background detection threshold (low)
uniform float dark_mode_bg_threshold_high;  // Dark mode background detection threshold (high)

// Gaussian blur kernel for 5x5 blur
const float blur_kernel[25] = float[](
    1.0/256.0, 4.0/256.0,  6.0/256.0,  4.0/256.0,  1.0/256.0,
    4.0/256.0, 16.0/256.0, 24.0/256.0, 16.0/256.0, 4.0/256.0,
    6.0/256.0, 24.0/256.0, 36.0/256.0, 24.0/256.0, 6.0/256.0,
    4.0/256.0, 16.0/256.0, 24.0/256.0, 16.0/256.0, 4.0/256.0,
    1.0/256.0, 4.0/256.0,  6.0/256.0,  4.0/256.0,  1.0/256.0
);

// Luminance coefficients (Rec. 601 standard)
const vec3 luminance_coeffs = vec3(0.299, 0.587, 0.114);

//http://gamedev.stackexchange.com/questions/59797/glsl-shader-change-hue-saturation-brightness
vec3 rgb2hsv(vec3 c)
{
    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));
    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));

    float d = q.x - min(q.w, q.y);
    float e = 1.0e-10;
    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
}

vec3 hsv2rgb(vec3 c)
{
    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
}

vec3 applyBlur(vec2 uv) {
    vec2 texelSize = 1.0 / vec2(textureSize(pdf_texture, 0));
    vec3 result = vec3(0.0);

    // Scale blur radius based on blur_amount (0.0 - 1.0)
    // blur_amount controls how far we sample neighboring pixels
    float blur_scale = blur_amount * 2.0;  // Scale factor for blur radius

    int index = 0;
    for (int y = -2; y <= 2; y++) {
        for (int x = -2; x <= 2; x++) {
            vec2 offset = vec2(float(x), float(y)) * texelSize * blur_scale;
            result += texture(pdf_texture, uv + offset).rgb * blur_kernel[index];
            index++;
        }
    }

    return result;
}

void main(){
    vec3 tempcolor = texture(pdf_texture, uvs).rgb;
    vec3 inv = (0.5-tempcolor)*contrast+0.5; //Invert colors and shift colors from range 0.0 - 1.0 to -0.5 - 0.5, apply contrast and shift back to 0.0 - 1.0. This way contrast applies on both whites and blacks
    vec3 hsvcolor = rgb2hsv(inv); //transform to hsv
    float new_hue = mod(hsvcolor.r + 0.5, 1.0); // shift hue 180 degrees to compensate hue shift from inverting colors 
    vec3 newcolor = hsv2rgb(vec3(new_hue,hsvcolor.gb)); 
    
    // In dark mode, text becomes light and background becomes dark
    // So we invert the logic: light pixels (text) get full opacity
    float luminance = dot(newcolor, luminance_coeffs);
    
    // Determine background factor (dark pixels in dark mode are background)
    // Note: thresholds are inverted for dark mode (high, low instead of low, high)
    float backgroundFactor = smoothstep(dark_mode_bg_threshold_high, dark_mode_bg_threshold_low, luminance);
    
    // Apply blur to background
    vec3 blurred_temp = applyBlur(uvs);
    vec3 blurred_inv = (0.5-blurred_temp)*contrast+0.5;
    vec3 blurred_hsv = rgb2hsv(blurred_inv);
    float blurred_hue = mod(blurred_hsv.r + 0.5, 1.0);
    vec3 blurred_final = hsv2rgb(vec3(blurred_hue, blurred_hsv.gb));
    
    vec3 finalColor = mix(newcolor, blurred_final, backgroundFactor);
    
    // For dark pixels (background), use transparency
    // For light pixels (text/content), use full opacity
    float alpha = mix(transparency, 1.0, smoothstep(dark_mode_bg_threshold_low, dark_mode_bg_threshold_high, luminance));
    
    color = vec4(finalColor, alpha);
}
