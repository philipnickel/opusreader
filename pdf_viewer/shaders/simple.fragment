#version 330 core

out vec4 color;
in vec2 screen_pos;
in vec2 uvs;
uniform sampler2D pdf_texture;
uniform float transparency;
uniform float blur_amount;  // Blur strength: 0.0 = no blur, 1.0 = full blur
uniform float bg_threshold_low;   // Background detection threshold (low)
uniform float bg_threshold_high;  // Background detection threshold (high)

// Gaussian blur kernel for 5x5 blur
const float blur_kernel[25] = float[](
    1.0/256.0, 4.0/256.0,  6.0/256.0,  4.0/256.0,  1.0/256.0,
    4.0/256.0, 16.0/256.0, 24.0/256.0, 16.0/256.0, 4.0/256.0,
    6.0/256.0, 24.0/256.0, 36.0/256.0, 24.0/256.0, 6.0/256.0,
    4.0/256.0, 16.0/256.0, 24.0/256.0, 16.0/256.0, 4.0/256.0,
    1.0/256.0, 4.0/256.0,  6.0/256.0,  4.0/256.0,  1.0/256.0
);

// Luminance coefficients (Rec. 601 standard)
const vec3 luminance_coeffs = vec3(0.299, 0.587, 0.114);

vec3 applyBlur(vec2 uv) {
    // Get texture size for proper pixel offset calculation
    vec2 texelSize = 1.0 / vec2(textureSize(pdf_texture, 0));
    vec3 result = vec3(0.0);

    // Scale blur radius based on blur_amount (0.0 - 1.0)
    // blur_amount controls how far we sample neighboring pixels
    float blur_scale = blur_amount * 2.0;  // Scale factor for blur radius

    // Apply 5x5 Gaussian blur with dynamic radius
    int index = 0;
    for (int y = -2; y <= 2; y++) {
        for (int x = -2; x <= 2; x++) {
            vec2 offset = vec2(float(x), float(y)) * texelSize * blur_scale;
            result += texture(pdf_texture, uv + offset).rgb * blur_kernel[index];
            index++;
        }
    }

    return result;
}

void main(){
    vec3 rgb = texture(pdf_texture, uvs).rgb;

    // Calculate luminance to detect text vs background
    // Text is typically dark, background is light
    float luminance = dot(rgb, luminance_coeffs);

    // Determine if this is background or text
    // smoothstep creates a smooth transition between thresholds
    float backgroundFactor = smoothstep(bg_threshold_low, bg_threshold_high, luminance);
    
    // Apply blur only to background pixels
    vec3 blurred = applyBlur(uvs);
    vec3 finalColor = mix(rgb, blurred, backgroundFactor);
    
    // For DARK pixels (text/content) use FULL opacity
    // For LIGHT pixels (background) use transparency
    float alpha = mix(1.0, transparency, backgroundFactor);
    
    color = vec4(finalColor, alpha);
}
