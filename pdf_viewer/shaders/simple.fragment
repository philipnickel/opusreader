#version 330 core

out vec4 color;
in vec2 screen_pos;
in vec2 uvs;
uniform sampler2D pdf_texture;
uniform float transparency;

// Gaussian blur kernel for 5x5 blur
const float blur_kernel[25] = float[](
    1.0/256.0, 4.0/256.0,  6.0/256.0,  4.0/256.0,  1.0/256.0,
    4.0/256.0, 16.0/256.0, 24.0/256.0, 16.0/256.0, 4.0/256.0,
    6.0/256.0, 24.0/256.0, 36.0/256.0, 24.0/256.0, 6.0/256.0,
    4.0/256.0, 16.0/256.0, 24.0/256.0, 16.0/256.0, 4.0/256.0,
    1.0/256.0, 4.0/256.0,  6.0/256.0,  4.0/256.0,  1.0/256.0
);

vec3 applyBlur(vec2 uv) {
    // Get texture size for proper pixel offset calculation
    vec2 texelSize = 1.0 / vec2(textureSize(pdf_texture, 0));
    vec3 result = vec3(0.0);
    
    // Apply 5x5 Gaussian blur
    int index = 0;
    for (int y = -2; y <= 2; y++) {
        for (int x = -2; x <= 2; x++) {
            vec2 offset = vec2(float(x), float(y)) * texelSize;
            result += texture(pdf_texture, uv + offset).rgb * blur_kernel[index];
            index++;
        }
    }
    
    return result;
}

void main(){
    vec3 rgb = texture(pdf_texture, uvs).rgb;
    
    // Calculate luminance to detect text vs background
    // Text is typically dark, background is light
    float luminance = dot(rgb, vec3(0.299, 0.587, 0.114));
    
    // Determine if this is background or text
    // smoothstep creates a smooth transition
    float backgroundFactor = smoothstep(0.3, 0.7, luminance);
    
    // Apply blur only to background pixels
    vec3 blurred = applyBlur(uvs);
    vec3 finalColor = mix(rgb, blurred, backgroundFactor);
    
    // For DARK pixels (text/content) use FULL opacity
    // For LIGHT pixels (background) use transparency
    float alpha = mix(1.0, transparency, backgroundFactor);
    
    color = vec4(finalColor, alpha);
}
